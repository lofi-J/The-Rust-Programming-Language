# 자동화 테스트 작성하기

## 테스트 작성 방법

테스트는 코드가 의도대로 기능하는지 검증하는 함수이다. 테스트 함수는 보통 3가지 동작을 수행한다.

1. 필요한 데이터나 상태 설정
2. 테스트할 코드의 실행
3. 의도한 결과가 나오는지 확인

### cargo test

`cargo test` Rust가 특정 규칙에 따라 테스트 함수들을 자동으로 찾아서 실행.</br>

#### #[test] 어노테이션이 붙은 함수(**테스트로 인식되는 함수**)

```rust
#[test]
    fn it_works() {
        let result = 2 + 3;
        assert_eq!(result, 5);
    }
```

#### 관례적으로 테스트는 tests 모듈로 분리

```rust
// tests 모듈 내부의 **테스트들**
mod tests {
  #[test]
  fn some() {}
}
```

## 테스트 실행 방법 제어

`cargo run` 명령어가 코드를 컴파일하고 생성된 바이너리를 실행하는 것과 마찬가지로 `cargo test`명령어는
코드를 테스트 모드에서 컴파일 하고 생성된 바이너리를 실행한다.

`cargo test`에 의해 생성된 바이너리의 기본 동작은 모든 테스트를 병렬로 실행하고 테스트가 수행되느 동안 발생된 출력을 캡처하는 것으로, 출력이 표시되는 것을 막고 테스트의 결고와 관련된 출력을 읽기 편하게 해준다.

`cargo test --help`, `cargo test -- --help` 명령어를 통해 테스트의 기본 동작을 변경할 수 있는 옵션들을 확인할 수 있다.

### 테스트를 병렬 또는 순차적으로 실행하기

테스트는 기본적으로 스레드를 사용해 병렬 실행되는데, 이는 효율적이지만 각 테스트가 같은 디렉터리, env등 서로 자원을 공유하거나 다른 테스트에 의존되지 않기를 원할 수 있다.

테스트를 병렬로 실행하고 싶지 않거나, 사용할 스레드의 개수에 조정이 필요할 경우에는 --test-threads플래그를 사용할 수 있다.
`cargo test -- --test-threads=1`

### 테스트 출력 표시하기

기본적으로, Rust테스트 라이브러리는 테스트의 출력을 캡처해 기본 동작으로(읽기 변하게 테스트와 관련된 출력만 표시) println!매크로를 호출해도 터미널에서 출력을 볼 수 없다. (실패한 테스트에 한해서는 출력이 보임)

`cargo test -- --show-output` 플래그를 사용해 성공한 테스트에서도 출력한 내용을 보도록 제어할 수 있다.

### 테스트 이름을 지정해 일부 테스트만 실행하기

테스트를 아무 인수 없이 실행하면 모든 테스트가 병렬로 실행되지만 `cargo test <some_fn>` 플래그를 이용해 해당 테스트만 실행할 수 있다.

또한 Rust의 네이밍 규칙에 따르면 함수명을 snake_case로 명명하는데 이를 이용해 특정 단어가 포함된 테스트만 실행하도록 할 수 있다.

`cargo test add` 명령어를 수행할 경우 테스트 함수명에 "add"가 포함된 모든 테스트가 실행된다.(모듈명으로도 가능)

### 시간이 오래걸리는 테스트는 무시하기

```rust
#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
```

이처럼 ignore 어노테이션을 할당하면 해당 테스는 무시된다.
따로 테스트를 진행하기위해
`cargo test -- --ignored` 명령어를 통해 무시된 테스트만 실행되도록 할수 있다.
`cargo test -- --include-ignored` 명령어를 통해 무시된 테스트를 포함한 모든 테스트를 실행 할수 있다.

## 테스트 조직화

Rust커뮤니티에서 테스트를 크게 유닛 테스트(unit test, 단위 테스트), 통합 테스트(integration test) 두 종류로 나눈다.

안정적인 테스트를 위해 유닛 테스트, 통합 테스트를 모두 작성하는것이 좋다.

### 유닛 테스트

유닛 테스트는 각 코드 단위를 나머지 코드와 분리하여, 제대로 작동하지 않는 코드가 어느 부분인지 빠르게 파악하는 것이 목적이다. 각 파일에 tests 모듈을 만들고 `cfg(test)`를 어노테이션 하는것이 일반적인 관례이다.

#### 테스트 모듈과 #[cfg(test)]

테스트 모듈에 어노테이션하는 `#[cfg(test)]`코드가 `cargo build`명령어가 아닌 `cargo test`명령어 실해 시에만 컴파일 및 실행될 것을 러스트에게 전달한다.

통합 테스트는 별도의 디렉터리에 위치하기 때문에 `#[cfg(test)]`어노테이션이 필요없지만, 유닛 테스트와 기능 함수는 일반 코드와 함께 작성되기 때문에 `#[cfg(test)]`어노테이션이 필요하다. (컴파일 결과물에 포함되지 않도록)

### 통합 테스트

통합 테스트의 목적은 라이브러리의 여러 부분을 함께 사용했을 때 정상 동작을 확인하기 위함이 목적이다.
각각 따로 정상 동작하는 코드도 함께 동작했을 때는 문제가 발생할 수 있기 때문

#### tests디렉터리

프로젝트 최상위 src옆에 tests디렉터리를 생성한다.
cargo는 디렉터리 내 통합 테스트 파일을 자동으로 인식한다.

```mdx
adder
├── Cargo.lock
├── Cargo.toml
├── src
│ └── lib.rs
└── tests
| └── integration_test.rs
```

통합 테스트의 대상이 되는 tests하위의 테스트 파일 내 코드에는 `#[cfg(test)]`어노테이션이 필요 없다.

cargo에서 tests 디렉터리를 특별 취급하여, cargo test시에만 컴파일을 진행한다.

